Transcript: linked list is a linear data structure unlike arrays linked lists are not stored in a contiguous location the elements are linked using pointers arrays can be used to store linear data of similar types but erase off the following limitations the size of array is fixed so we know the upper limit on the elements in advance also generally the allocated memory is equal to the upper limit irrespective of the use. Here is a linked list with values A, B, C, D. A is the head of the linked list and each node has prev and next pointer. Tail's next pointer is pointing to NULL (node has dashed borders). Next, E is inserted after node C by updating pointers: C's next points to E and E's next points to C's old next pointer. A traversal of a linked list starts at the head and follows the next pointers.
Js: let nodes = []; let edges = []; function setup() { createCanvas(800, 400); textAlign(CENTER, CENTER); // Initial linked list: A -> B -> C -> D nodes.push(new Node('A', 100, 200, true)); nodes.push(new Node('B', 200, 200)); nodes.push(new Node('C', 300, 200)); nodes.push(new Node('D', 400, 200, false, true)); // Insert E after C let eNode = new Node('E', 350, 250); nodes.splice(3, 0, eNode); // Update edges for (let i = 0; i < nodes.length - 1; i++) { edges.push(new Edge(nodes[i], nodes[i + 1])); } } function draw() { background(255); // Draw edges for (let edge of edges) { edge.display(); } // Draw nodes for (let node of nodes) { node.display(); } } class Node { constructor(value, x, y, isHead = false, isTail = false) { this.value = value; this.x = x; this.y = y; this.isHead = isHead; this.isTail = isTail; } display() { stroke(0); if (this.isTail) { stroke(0, 0, 0, 100); // Dashed border for tail drawingContext.setLineDash([5, 5]); } else { drawingContext.setLineDash([]); } fill(255); ellipse(this.x, this.y, 40, 40); fill(0); noStroke(); text(this.value, this.x, this.y); if (this.isHead) { text('Head', this.x, this.y - 30); } if (this.isTail) { text('Tail', this.x, this.y + 30); } } } class Edge { constructor(fromNode, toNode) { this.fromNode = fromNode; this.toNode = toNode; } display() { stroke(0); drawingContext.setLineDash([]); line(this.fromNode.x, this.fromNode.y, this.toNode.x, this.toNode.y); // Draw arrowhead let angle = atan2(this.toNode.y - this.fromNode.y, this.toNode.x - this.fromNode.x); push(); translate(this.toNode.x, this.toNode.y); rotate(angle - HALF_PI); triangle(-5, 0, 5, 0, 0, 10); pop(); } }
